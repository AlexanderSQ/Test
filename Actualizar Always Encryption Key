-- ===================================
-- SCRIPT OPTIMIZADO DE ROTACIÓN DE ALWAYS ENCRYPTED KEYS
-- Tabla: TB_FUNCTIONAL_AUDIT (100,000 registros)
-- Optimizado para menor consumo de recursos
-- ===================================

SET NOCOUNT ON; -- Reduce tráfico de red
SET STATISTICS TIME ON; -- Para medir tiempos de SQL Server
SET STATISTICS IO ON; -- Para medir I/O

-- Variable de tabla para auditoría (más eficiente que tabla temporal)
DECLARE @RotationAudit TABLE (
    StepNumber INT,
    StepName VARCHAR(100),
    StartTime DATETIME2(3), -- Menor precisión = menos storage
    EndTime DATETIME2(3),
    DurationSeconds DECIMAL(10,3),
    RowsAffected BIGINT,
    Status VARCHAR(20)
);

DECLARE @StepStart DATETIME2(3);
DECLARE @StepEnd DATETIME2(3);
DECLARE @StepNumber INT = 1;
DECLARE @RowsAffected BIGINT;

-- Configuración para optimizar rendimiento
DECLARE @OriginalDeadlockPriority INT;
SELECT @OriginalDeadlockPriority = deadlock_priority FROM sys.dm_exec_sessions WHERE session_id = @@SPID;
SET DEADLOCK_PRIORITY HIGH; -- Prioridad alta para evitar rollbacks

PRINT '========================================';
PRINT 'INICIANDO ROTACIÓN OPTIMIZADA - ' + FORMAT(GETDATE(), 'yyyy-MM-dd HH:mm:ss');
PRINT 'Tabla: TB_FUNCTIONAL_AUDIT (~100,000 registros)';
PRINT '========================================';

-- ESTIMACIÓN INICIAL
PRINT 'Paso 0: Análisis inicial de la tabla...';
SET @StepStart = GETDATE();

DECLARE @TableInfo TABLE (
    TableName SYSNAME,
    TotalRows BIGINT,
    SizeMB DECIMAL(10,2),
    EncryptedColumns INT,
    EstimatedMinutes DECIMAL(10,2)
);

INSERT INTO @TableInfo
SELECT 
    t.name AS TableName,
    p.rows AS TotalRows,
    CAST((SUM(a.total_pages) * 8.0) / 1024 AS DECIMAL(10,2)) AS SizeMB,
    COUNT(c.column_id) AS EncryptedColumns,
    -- Estimación: ~2-5 segundos por cada 1000 filas por columna encriptada
    CAST((p.rows * COUNT(c.column_id)) / 1000.0 * 3.5 / 60.0 AS DECIMAL(10,2)) AS EstimatedMinutes
FROM sys.tables t
INNER JOIN sys.partitions p ON t.object_id = p.object_id
INNER JOIN sys.allocation_units a ON p.partition_id = a.container_id
LEFT JOIN sys.columns c ON t.object_id = c.object_id AND c.encryption_type IS NOT NULL
WHERE t.name = 'TB_FUNCTIONAL_AUDIT'
    AND p.index_id IN (0, 1) -- Solo heap o clustered index
GROUP BY t.name, p.rows;

SET @StepEnd = GETDATE();
INSERT INTO @RotationAudit VALUES (@StepNumber, 'Initial Analysis', @StepStart, @StepEnd, DATEDIFF_BIG(millisecond, @StepStart, @StepEnd)/1000.0, 0, 'SUCCESS');

-- Mostrar estimación
SELECT 
    'ESTIMACIÓN DEL PROCESO:' AS Info,
    TableName,
    FORMAT(TotalRows, 'N0') AS TotalRows,
    SizeMB,
    EncryptedColumns,
    EstimatedMinutes AS EstimatedMinutes
FROM @TableInfo;

SET @StepNumber = @StepNumber + 1;

-- PASO 1: Crear nuevo Column Master Key
PRINT 'Paso 1: Creando nuevo Column Master Key...';
SET @StepStart = GETDATE();

BEGIN TRY
    -- Nota: Ajustar según tu configuración de key store
    CREATE COLUMN MASTER KEY [CMK_TB_FUNCTIONAL_AUDIT_NEW]
    WITH (
        KEY_STORE_PROVIDER_NAME = 'MSSQL_CERTIFICATE_STORE',
        KEY_PATH = 'CurrentUser/My/tu_thumbprint_aqui'
        -- Para Azure Key Vault usar:
        -- KEY_STORE_PROVIDER_NAME = 'AZURE_KEY_VAULT',
        -- KEY_PATH = 'https://tu-keyvault.vault.azure.net/keys/tu-key-name'
    );
    
    SET @StepEnd = GETDATE();
    INSERT INTO @RotationAudit VALUES (@StepNumber, 'Create CMK', @StepStart, @StepEnd, DATEDIFF_BIG(millisecond, @StepStart, @StepEnd)/1000.0, 1, 'SUCCESS');
    PRINT '✓ Column Master Key creado exitosamente';
END TRY
BEGIN CATCH
    SET @StepEnd = GETDATE();
    INSERT INTO @RotationAudit VALUES (@StepNumber, 'Create CMK', @StepStart, @StepEnd, DATEDIFF_BIG(millisecond, @StepStart, @StepEnd)/1000.0, 0, 'ERROR');
    PRINT '✗ Error creando CMK: ' + ERROR_MESSAGE();
    GOTO ErrorExit;
END CATCH

SET @StepNumber = @StepNumber + 1;

-- PASO 2: Crear nuevo Column Encryption Key
PRINT 'Paso 2: Creando nuevo Column Encryption Key...';
SET @StepStart = GETDATE();

BEGIN TRY
    CREATE COLUMN ENCRYPTION KEY [CEK_TB_FUNCTIONAL_AUDIT_NEW]
    WITH VALUES (
        COLUMN_MASTER_KEY = [CMK_TB_FUNCTIONAL_AUDIT_NEW],
        ALGORITHM = 'RSA_OAEP'
    );
    
    SET @StepEnd = GETDATE();
    INSERT INTO @RotationAudit VALUES (@StepNumber, 'Create CEK', @StepStart, @StepEnd, DATEDIFF_BIG(millisecond, @StepStart, @StepEnd)/1000.0, 1, 'SUCCESS');
    PRINT '✓ Column Encryption Key creado exitosamente';
END TRY
BEGIN CATCH
    SET @StepEnd = GETDATE();
    INSERT INTO @RotationAudit VALUES (@StepNumber, 'Create CEK', @StepStart, @StepEnd, DATEDIFF_BIG(millisecond, @StepStart, @StepEnd)/1000.0, 0, 'ERROR');
    PRINT '✗ Error creando CEK: ' + ERROR_MESSAGE();
    GOTO ErrorExit;
END CATCH

SET @StepNumber = @StepNumber + 1;

-- PASO 3: Preparar rotación de columnas
PRINT 'Paso 3: Identificando columnas para rotación...';
SET @StepStart = GETDATE();

DECLARE @ColumnRotations TABLE (
    ColumnName SYSNAME,
    DataType NVARCHAR(128),
    IsNullable BIT,
    CurrentCEK SYSNAME,
    RotationOrder INT,
    ColumnSize BIGINT
);

INSERT INTO @ColumnRotations
SELECT 
    c.name AS ColumnName,
    CASE 
        WHEN tp.name IN ('varchar', 'char', 'varbinary', 'binary') THEN 
            tp.name + '(' + CASE WHEN c.max_length = -1 THEN 'MAX' ELSE CAST(c.max_length AS VARCHAR) END + ')'
        WHEN tp.name IN ('nvarchar', 'nchar') THEN 
            tp.name + '(' + CASE WHEN c.max_length = -1 THEN 'MAX' ELSE CAST(c.max_length/2 AS VARCHAR) END + ')'
        WHEN tp.name IN ('decimal', 'numeric') THEN 
            tp.name + '(' + CAST(c.precision AS VARCHAR) + ',' + CAST(c.scale AS VARCHAR) + ')'
        WHEN tp.name IN ('float') THEN 
            tp.name + CASE WHEN c.precision = 53 THEN '' ELSE '(' + CAST(c.precision AS VARCHAR) + ')' END
        ELSE tp.name
    END AS DataType,
    c.is_nullable,
    cek.name AS CurrentCEK,
    ROW_NUMBER() OVER (ORDER BY c.column_id) AS RotationOrder,
    CASE 
        WHEN c.max_length = -1 THEN 8000 -- Estimación para MAX
        ELSE c.max_length 
    END AS ColumnSize
FROM sys.tables t
INNER JOIN sys.columns c ON t.object_id = c.object_id
INNER JOIN sys.types tp ON c.user_type_id = tp.user_type_id
INNER JOIN sys.column_encryption_keys cek ON c.column_encryption_key_id = cek.column_encryption_key_id
WHERE t.name = 'TB_FUNCTIONAL_AUDIT'
    AND c.encryption_type IS NOT NULL;

DECLARE @TotalColumns INT = (SELECT COUNT(*) FROM @ColumnRotations);
DECLARE @EstimatedTotalTime DECIMAL(10,2) = (SELECT EstimatedMinutes FROM @TableInfo);

SET @StepEnd = GETDATE();
INSERT INTO @RotationAudit VALUES (@StepNumber, 'Column Analysis', @StepStart, @StepEnd, DATEDIFF_BIG(millisecond, @StepStart, @StepEnd)/1000.0, @TotalColumns, 'SUCCESS');

PRINT 'Encontradas ' + CAST(@TotalColumns AS VARCHAR) + ' columnas encriptadas';
PRINT 'Tiempo estimado total: ' + CAST(@EstimatedTotalTime AS VARCHAR) + ' minutos';

-- Mostrar plan de rotación
SELECT 
    'PLAN DE ROTACIÓN:' AS Plan,
    RotationOrder AS [Orden],
    ColumnName AS [Columna],
    DataType AS [Tipo],
    CurrentCEK AS [CEK Actual]
FROM @ColumnRotations 
ORDER BY RotationOrder;

SET @StepNumber = @StepNumber + 1;

-- PASO 4: Rotación de columnas (optimizada)
PRINT 'Paso 4: Iniciando rotación de columnas...';
PRINT 'IMPORTANTE: Este proceso puede tomar varios minutos con 100,000 registros';
PRINT '----------------------------------------';

DECLARE @CurrentColumn SYSNAME;
DECLARE @CurrentDataType NVARCHAR(128);
DECLARE @CurrentOrder INT;
DECLARE @SQL NVARCHAR(MAX);
DECLARE @ProgressPct DECIMAL(5,2);

-- Cursor optimizado
DECLARE column_cursor CURSOR LOCAL FAST_FORWARD FOR
SELECT ColumnName, DataType, RotationOrder
FROM @ColumnRotations
ORDER BY RotationOrder;

OPEN column_cursor;
FETCH NEXT FROM column_cursor INTO @CurrentColumn, @CurrentDataType, @CurrentOrder;

WHILE @@FETCH_STATUS = 0
BEGIN
    SET @ProgressPct = CAST(@CurrentOrder AS DECIMAL) / @TotalColumns * 100;
    PRINT FORMAT(GETDATE(), 'HH:mm:ss') + ' - Rotando columna ' + CAST(@CurrentOrder AS VARCHAR) + '/' + CAST(@TotalColumns AS VARCHAR) + 
          ' (' + FORMAT(@ProgressPct, 'N1') + '%): ' + @CurrentColumn;
    
    SET @StepStart = GETDATE();
    
    BEGIN TRY
        -- SQL dinámico optimizado
        SET @SQL = N'ALTER TABLE TB_FUNCTIONAL_AUDIT ALTER COLUMN [' + @CurrentColumn + N'] ' + @CurrentDataType + 
                   N' ENCRYPTED WITH (
                       COLUMN_ENCRYPTION_KEY = [CEK_TB_FUNCTIONAL_AUDIT_NEW],
                       ENCRYPTION_TYPE = DETERMINISTIC,
                       ALGORITHM = ''AEAD_AES_256_CBC_HMAC_SHA_256''
                   )';
        
        EXEC sp_executesql @SQL;
        SET @RowsAffected = @@ROWCOUNT;
        
        SET @StepEnd = GETDATE();
        INSERT INTO @RotationAudit VALUES (@StepNumber, 'Rotate: ' + @CurrentColumn, @StepStart, @StepEnd, 
                                         DATEDIFF_BIG(millisecond, @StepStart, @StepEnd)/1000.0, @RowsAffected, 'SUCCESS');
        
        PRINT '  ✓ Completado en ' + CAST(DATEDIFF_BIG(millisecond, @StepStart, @StepEnd)/1000.0 AS VARCHAR(10)) + ' segundos';
        
    END TRY
    BEGIN CATCH
        SET @StepEnd = GETDATE();
        INSERT INTO @RotationAudit VALUES (@StepNumber, 'Rotate: ' + @CurrentColumn, @StepStart, @StepEnd, 
                                         DATEDIFF_BIG(millisecond, @StepStart, @StepEnd)/1000.0, 0, 'ERROR');
        PRINT '  ✗ Error: ' + ERROR_MESSAGE();
        
        -- Decidir si continuar o parar
        IF ERROR_NUMBER() IN (2628, 2627, 547) -- Errores críticos
        BEGIN
            PRINT 'Error crítico detectado. Deteniendo proceso.';
            CLOSE column_cursor;
            DEALLOCATE column_cursor;
            GOTO ErrorExit;
        END
        ELSE
        BEGIN
            PRINT 'Error no crítico. Continuando con siguiente columna...';
        END
    END CATCH
    
    SET @StepNumber = @StepNumber + 1;
    
    -- Pausa pequeña para reducir carga del sistema
    WAITFOR DELAY '00:00:01';
    
    FETCH NEXT FROM column_cursor INTO @CurrentColumn, @CurrentDataType, @CurrentOrder;
END

CLOSE column_cursor;
DEALLOCATE column_cursor;

-- FINALIZACIÓN EXITOSA
PRINT '========================================';
PRINT 'ROTACIÓN COMPLETADA EXITOSAMENTE';
PRINT 'Finalizado: ' + FORMAT(GETDATE(), 'yyyy-MM-dd HH:mm:ss');
PRINT '========================================';
GOTO ShowResults;

-- MANEJO DE ERRORES
ErrorExit:
PRINT '========================================';
PRINT 'PROCESO INTERRUMPIDO POR ERROR';
PRINT 'Tiempo: ' + FORMAT(GETDATE(), 'yyyy-MM-dd HH:mm:ss');
PRINT '========================================';

ShowResults:
-- Restaurar configuración original
SET DEADLOCK_PRIORITY @OriginalDeadlockPriority;
SET STATISTICS TIME OFF;
SET STATISTICS IO OFF;

-- ===================================
-- REPORTES DE AUDITORÍA
-- ===================================

PRINT '';
PRINT '=== REPORTE DETALLADO DE TIEMPOS ===';
SELECT 
    StepNumber AS [#],
    StepName AS [Operación],
    FORMAT(StartTime, 'HH:mm:ss.fff') AS [Inicio],
    FORMAT(EndTime, 'HH:mm:ss.fff') AS [Fin],
    DurationSeconds AS [Segundos],
    FORMAT(DurationSeconds/60.0, 'N2') AS [Minutos],
    FORMAT(RowsAffected, 'N0') AS [Filas],
    Status AS [Estado]
FROM @RotationAudit
ORDER BY StepNumber;

PRINT '';
PRINT '=== RESUMEN EJECUTIVO ===';
SELECT 
    COUNT(*) AS [Total Pasos],
    SUM(CASE WHEN Status = 'SUCCESS' THEN 1 ELSE 0 END) AS [Exitosos],
    SUM(CASE WHEN Status = 'ERROR' THEN 1 ELSE 0 END) AS [Con Error],
    FORMAT(MIN(StartTime), 'HH:mm:ss') AS [Inicio Proceso],
    FORMAT(MAX(EndTime), 'HH:mm:ss') AS [Fin Proceso],
    CAST(DATEDIFF_BIG(millisecond, MIN(StartTime), MAX(EndTime))/1000.0 AS DECIMAL(10,1)) AS [Total Segundos],
    FORMAT(DATEDIFF_BIG(millisecond, MIN(StartTime), MAX(EndTime))/60000.0, 'N2') AS [Total Minutos]
FROM @RotationAudit;

PRINT '';
PRINT '=== RENDIMIENTO POR TIPO DE OPERACIÓN ===';
SELECT 
    CASE 
        WHEN StepName LIKE 'Create%' THEN 'Creación de Keys'
        WHEN StepName LIKE 'Rotate%' THEN 'Rotación de Columnas'
        WHEN StepName LIKE '%Analysis' THEN 'Análisis'
        ELSE 'Otras'
    END AS [Tipo Operación],
    COUNT(*) AS [Cantidad],
    FORMAT(AVG(DurationSeconds), 'N2') AS [Promedio Seg],
    FORMAT(MIN(DurationSeconds), 'N2') AS [Mínimo Seg],
    FORMAT(MAX(DurationSeconds), 'N2') AS [Máximo Seg],
    FORMAT(SUM(DurationSeconds), 'N1') AS [Total Seg]
FROM @RotationAudit
WHERE Status = 'SUCCESS'
GROUP BY 
    CASE 
        WHEN StepName LIKE 'Create%' THEN 'Creación de Keys'
        WHEN StepName LIKE 'Rotate%' THEN 'Rotación de Columnas'
        WHEN StepName LIKE '%Analysis' THEN 'Análisis'
        ELSE 'Otras'
    END
ORDER BY [Total Seg] DESC;

-- VERIFICACIÓN POST-ROTACIÓN
PRINT '';
PRINT '=== VERIFICACIÓN POST-ROTACIÓN ===';
SELECT 
    c.name AS [Columna],
    c.encryption_type_desc AS [Tipo Encriptación],
    cek.name AS [CEK],
    cmk.name AS [CMK],
    CASE WHEN cek.name LIKE '%_NEW' THEN '✓ Migrada' ELSE '⚠ Pendiente' END AS [Estado]
FROM sys.tables t
INNER JOIN sys.columns c ON t.object_id = c.object_id
INNER JOIN sys.column_encryption_keys cek ON c.column_encryption_key_id = cek.column_encryption_key_id
INNER JOIN sys.column_master_keys cmk ON cek.column_master_key_id = cmk.column_master_key_id
WHERE t.name = 'TB_FUNCTIONAL_AUDIT'
    AND c.encryption_type IS NOT NULL
ORDER BY c.column_id;

PRINT '';
PRINT '=== SIGUIENTE PASO ===';
PRINT 'Una vez verificado el funcionamiento, ejecutar script de cleanup para eliminar keys antiguas';

SET NOCOUNT OFF;
